
type Tag {
  key: String
  value: String
}

input TagInput {
    key: String
    value: String
}

input AwsAddTagsAction {
    tags: [TagInput]
}

type Vpc {
   vpcId: String
   state: String
   cidrBlock: String
   dhcpOptionsId: String
   tags: [Tag]
   instanceTenancy: String
   isDefault: Boolean
   ipv6CidrBlockAssociationSet: [String]
 }

 input AwsVpcFilter {
   idContains: String
   cidrContains: String
   tagsContains: [TagInput]
 }

 type Instance {
   instanceId: String
   imageId: String
   state: String
   privateDnsName: String
   publicDnsName: String
   stateTransitionReason: String
   keyName: String
   amiLaunchIndex: Int
   instanceType: String
   kernelId: String
   ramdiskId: String
   platform: String
   subnetId: String
   vpcId: String
   privateIpAddress: String
   publicIpAddress: String
   architecture: String
   rootDeviceType: String
   rootDeviceName: String
   virtualizationType: String
   instanceLifecycle: String
   spotInstanceRequestId: String
   clientToken: String
   sourceDestCheck: Boolean
   hypervisor: String
   ebsOptimized: Boolean
   sriovNetSupport: String
   enaSupport: Boolean
   productCodes: [String]
   launchTime: String
   placement: String
   monitoring: String
   stateReason: String
   blockDeviceMappings: [String]
   securityGroups: [String]
   networkInterfaces: [String]
   iamInstanceProfile: String
   tags: [Tag]
 }

 input AwsEc2InstanceFilter {
   idContains: String
   tagsContains: [TagInput]
 }

 type Query {
   vpcs(filter: AwsVpcFilter): [Vpc]
   ec2Instances(filter: AwsEc2InstanceFilter): [Instance]
 }

 type Mutation {
   vpcs(filter: AwsVpcFilter, addTags: AwsAddTagsAction): [Vpc]
   ec2Instances(filter: AwsEc2InstanceFilter, addTags: AwsAddTagsAction): [Instance]
 }

 schema {
   query: Query
   mutation: Mutation
 }
